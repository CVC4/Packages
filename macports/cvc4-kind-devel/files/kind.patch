diff --git a/contrib/run-script-casc24-fnt b/contrib/run-script-casc24-fnt
index b10d732..2a10c53 100755
--- a/contrib/run-script-casc24-fnt
+++ contrib/run-script-casc24-fnt
@@ -16,18 +16,18 @@ function trywith {
   (ulimit -t "$limit";$cvc4 -L tptp --szs-compliant --no-checking --no-interactive --dump-models --produce-models "$@" $bench) 2>/dev/null |
   (read result;
   case "$result" in
-    sat) echo "% SZS status" "Satisfiable for $filename";
-         echo "% SZS output" "start FiniteModel for $filename";
+    sat) echo "% SZS Satisfiable for $filename";
+         echo "% SZS output start FiniteModel for $filename";
          cat;
-         echo "% SZS output" "end FiniteModel for $filename";
+         echo "% SZS output end FiniteModel for $filename";
          exit 0;;
-    unsat) echo "% SZS status" "Unsatisfiable for $filename"; exit 0;;
-    conjecture-sat) echo "% SZS status" "CounterSatisfiable for $filename";
-                    echo "% SZS output" "start FiniteModel for $filename";
+    unsat) echo "% SZS Unsatisfiable for $filename"; exit 0;;
+    conjecture-sat) echo "% SZS CounterSatisfiable for $filename";
+                    echo "% SZS output start FiniteModel for $filename";
                     cat;
-                    echo "% SZS output" "end FiniteModel for $filename";
+                    echo "% SZS output end FiniteModel for $filename";
                     exit 0;;
-    conjecture-unsat) echo "% SZS status" "Theorem for $filename"; exit 0;;
+    conjecture-unsat) echo "% SZS Theorem for $filename"; exit 0;;
   esac; exit 1)
   if [ ${PIPESTATUS[1]} -eq 0 ]; then exit 0; fi
 }
@@ -35,4 +35,4 @@ function trywith {
 trywith 30 --finite-model-find --uf-ss-totality
 trywith 30 --finite-model-find --decision=justification --fmf-fmc
 trywith $to --finite-model-find --decision=justification
-echo "% SZS status" "GaveUp for $filename"
+echo "% SZS GaveUp for $filename"
\ No newline at end of file
diff --git a/contrib/run-script-casc24-fnt-no-models b/contrib/run-script-casc24-fnt-no-models
index 3b4d5e3..a189c10 100755
--- a/contrib/run-script-casc24-fnt-no-models
+++ contrib/run-script-casc24-fnt-no-models
@@ -14,23 +14,23 @@ filename=${file%.*}
 function trywith {
   result="$( ulimit -t "$1";shift;$cvc4 -L tptp --szs-compliant --no-checking --no-interactive "$@" $bench)"
   case "$result" in
-    sat) echo "% SZS status" "Satisfiable for $filename"; exit 0;;
-    unsat) echo "% SZS status" "Unsatisfiable for $filename"; exit 0;;
-    conjecture-sat) echo "% SZS status" "CounterSatisfiable for $filename"; exit 0;;
-    conjecture-unsat) echo "% SZS status" "Theorem for $filename"; exit 0;;
+    sat) echo "% SZS Satisfiable for $filename"; exit 0;;
+    unsat) echo "% SZS Unsatisfiable for $filename"; exit 0;;
+    conjecture-sat) echo "% SZS CounterSatisfiable for $filename"; exit 0;;
+    conjecture-unsat) echo "% SZS Theorem for $filename"; exit 0;;
   esac
 }
 function finishwith {
   result="$( $cvc4 -L tptp --szs-compliant --no-checking --no-interactive "$@" $bench)"
   case "$result" in
-    sat) echo "% SZS status" "Satisfiable for $filename"; exit 0;;
-    unsat) echo "% SZS status" "Unsatisfiable for $filename"; exit 0;;
-    conjecture-sat) echo "% SZS status" "CounterSatisfiable for $filename"; exit 0;;
-    conjecture-unsat) echo "% SZS status" "Theorem for $filename"; exit 0;;
+    sat) echo "% SZS Satisfiable for $filename"; exit 0;;
+    unsat) echo "% SZS Unsatisfiable for $filename"; exit 0;;
+    conjecture-sat) echo "% SZS CounterSatisfiable for $filename"; exit 0;;
+    conjecture-unsat) echo "% SZS Theorem for $filename"; exit 0;;
   esac
 }
 
 trywith 30 --finite-model-find --uf-ss-totality
 trywith 30 --finite-model-find --decision=justification --fmf-fmc
 trywith $to --finite-model-find --decision=justification
-echo "% SZS status" "GaveUp for $filename"
+echo "% SZS GaveUp for $filename"
\ No newline at end of file
diff --git a/contrib/run-script-casc24-fof b/contrib/run-script-casc24-fof
index b3ede0d..940e269 100755
--- a/contrib/run-script-casc24-fof
+++ contrib/run-script-casc24-fof
@@ -14,19 +14,19 @@ filename=${file%.*}
 function trywith {
   result="$( ulimit -t "$1";shift;$cvc4 -L tptp --szs-compliant --no-checking --no-interactive "$@" $bench)"
   case "$result" in
-    sat) echo "% SZS status" "Satisfiable for $filename"; exit 0;;
-    unsat) echo "% SZS status" "Unsatisfiable for $filename"; exit 0;;
-    conjecture-sat) echo "% SZS status" "CounterSatisfiable for $filename"; exit 0;;
-    conjecture-unsat) echo "% SZS status" "Theorem for $filename"; exit 0;;
+    sat) echo "% SZS Satisfiable for $filename"; exit 0;;
+    unsat) echo "% SZS Unsatisfiable for $filename"; exit 0;;
+    conjecture-sat) echo "% SZS CounterSatisfiable for $filename"; exit 0;;
+    conjecture-unsat) echo "% SZS Theorem for $filename"; exit 0;;
   esac
 }
 function finishwith {
   result="$( $cvc4 -L tptp --szs-compliant --no-checking --no-interactive "$@" $bench)"
   case "$result" in
-    sat) echo "% SZS status" "Satisfiable for $filename"; exit 0;;
-    unsat) echo "% SZS status" "Unsatisfiable for $filename"; exit 0;;
-    conjecture-sat) echo "% SZS status" "CounterSatisfiable for $filename"; exit 0;;
-    conjecture-unsat) echo "% SZS status" "Theorem for $filename"; exit 0;;
+    sat) echo "% SZS Satisfiable for $filename"; exit 0;;
+    unsat) echo "% SZS Unsatisfiable for $filename"; exit 0;;
+    conjecture-sat) echo "% SZS CounterSatisfiable for $filename"; exit 0;;
+    conjecture-unsat) echo "% SZS Theorem for $filename"; exit 0;;
   esac
 }
 
@@ -34,4 +34,4 @@ trywith 30
 trywith 15 --finite-model-find --fmf-inst-engine
 trywith 30 --finite-model-find --decision=justification --fmf-fmc
 trywith $to --decision=justification
-echo "% SZS status" "GaveUp for $filename"
+echo "% SZS GaveUp for $filename"
\ No newline at end of file
diff --git a/src/compat/cvc3_compat.cpp b/src/compat/cvc3_compat.cpp
index 601c251..0b3b743 100644
--- a/src/compat/cvc3_compat.cpp
+++ src/compat/cvc3_compat.cpp
@@ -197,7 +197,7 @@ bool Type::isBool() const {
 }
 
 bool Type::isSubtype() const {
-  return false;
+  return isPredicateSubtype();
 }
 
 Cardinality Type::card() const {
@@ -1075,14 +1075,11 @@ Type ValidityChecker::subrangeType(const Expr& l, const Expr& r) {
 }
 
 Type ValidityChecker::subtypeType(const Expr& pred, const Expr& witness) {
-  Unimplemented("Predicate subtyping not supported by CVC4 yet (sorry!)");
-  /*
   if(witness.isNull()) {
     return d_em->mkPredicateSubtype(pred);
   } else {
     return d_em->mkPredicateSubtype(pred, witness);
   }
-  */
 }
 
 Type ValidityChecker::tupleType(const Type& type0, const Type& type1) {
@@ -1296,7 +1293,20 @@ Type ValidityChecker::getBaseType(const Expr& e) {
 }
 
 Type ValidityChecker::getBaseType(const Type& t) {
-  return t.getBaseType();
+  Type type = t;
+  while(type.isPredicateSubtype()) {
+    type = CVC4::PredicateSubtype(type).getBaseType();
+  }
+  // We might still be a (primitive) subtype.  Check the types that can
+  // form the base of such a type.
+  if(type.isReal()) {
+    return d_em->realType();
+  }
+  assert(!type.isInteger());// should be handled by Real
+  if(type.isBoolean()) {
+    return d_em->booleanType();
+  }
+  return type;
 }
 
 Expr ValidityChecker::getTypePred(const Type&t, const Expr& e) {
diff --git a/src/expr/expr_manager_template.cpp b/src/expr/expr_manager_template.cpp
index 524bc20..8a9b672 100644
--- a/src/expr/expr_manager_template.cpp
+++ src/expr/expr_manager_template.cpp
@@ -731,7 +731,6 @@ SortConstructorType ExprManager::mkSortConstructor(const std::string& name,
               new TypeNode(d_nodeManager->mkSortConstructor(name, arity))));
 }
 
-/* - not in release 1.0
 Type ExprManager::mkPredicateSubtype(Expr lambda)
   throw(TypeCheckingException) {
   NodeManagerScope nms(d_nodeManager);
@@ -742,9 +741,7 @@ Type ExprManager::mkPredicateSubtype(Expr lambda)
     throw TypeCheckingException(this, &e);
   }
 }
-*/
 
-/* - not in release 1.0
 Type ExprManager::mkPredicateSubtype(Expr lambda, Expr witness)
   throw(TypeCheckingException) {
   NodeManagerScope nms(d_nodeManager);
@@ -755,7 +752,6 @@ Type ExprManager::mkPredicateSubtype(Expr lambda, Expr witness)
     throw TypeCheckingException(this, &e);
   }
 }
-*/
 
 Type ExprManager::mkSubrangeType(const SubrangeBounds& bounds)
   throw(TypeCheckingException) {
diff --git a/src/expr/expr_manager_template.h b/src/expr/expr_manager_template.h
index fd81c9b..79cfa25 100644
--- a/src/expr/expr_manager_template.h
+++ src/expr/expr_manager_template.h
@@ -443,9 +443,8 @@ public:
    * not a LAMBDA, or is ill-typed, or if CVC4 fails at proving that
    * the resulting predicate subtype is inhabited.
    */
-  // not in release 1.0
-  //Type mkPredicateSubtype(Expr lambda)
-  //  throw(TypeCheckingException);
+  Type mkPredicateSubtype(Expr lambda)
+    throw(TypeCheckingException);
 
   /**
    * Make a predicate subtype type defined by the given LAMBDA
@@ -454,9 +453,8 @@ public:
    * a LAMBDA, or is ill-typed, or if the witness is not a witness or
    * ill-typed.
    */
-  // not in release 1.0
-  //Type mkPredicateSubtype(Expr lambda, Expr witness)
-  //  throw(TypeCheckingException);
+  Type mkPredicateSubtype(Expr lambda, Expr witness)
+    throw(TypeCheckingException);
 
   /**
    * Make an integer subrange type as defined by the argument.
diff --git a/src/expr/type.cpp b/src/expr/type.cpp
index 71c25bd..48276f8 100644
--- a/src/expr/type.cpp
+++ src/expr/type.cpp
@@ -304,12 +304,10 @@ bool Type::isSortConstructor() const {
 }
 
 /** Is this a predicate subtype */
-/* - not in release 1.0
 bool Type::isPredicateSubtype() const {
   NodeManagerScope nms(d_nodeManager);
   return d_typeNode->isPredicateSubtype();
 }
-*/
 
 /** Is this an integer subrange */
 bool Type::isSubrange() const {
@@ -486,13 +484,11 @@ SortConstructorType::SortConstructorType(const Type& t)
   CheckArgument(isNull() || isSortConstructor(), this);
 }
 
-/* - not in release 1.0
 PredicateSubtype::PredicateSubtype(const Type& t)
   throw(IllegalArgumentException) :
   Type(t) {
   CheckArgument(isNull() || isPredicateSubtype(), this);
 }
-*/
 
 SubrangeType::SubrangeType(const Type& t)
   throw(IllegalArgumentException) :
@@ -606,7 +602,6 @@ BooleanType TesterType::getRangeType() const {
   return BooleanType(makeType(d_nodeManager->booleanType()));
 }
 
-/* - not in release 1.0
 Expr PredicateSubtype::getPredicate() const {
   NodeManagerScope nms(d_nodeManager);
   return d_typeNode->getSubtypePredicate().toExpr();
@@ -616,7 +611,6 @@ Type PredicateSubtype::getParentType() const {
   NodeManagerScope nms(d_nodeManager);
   return d_typeNode->getSubtypeParentType().toType();
 }
-*/
 
 SubrangeBounds SubrangeType::getSubrangeBounds() const {
   NodeManagerScope nms(d_nodeManager);
diff --git a/src/expr/type.h b/src/expr/type.h
index 5e4e862..30d1971 100644
--- a/src/expr/type.h
+++ src/expr/type.h
@@ -59,8 +59,7 @@ class RecordType;
 class SExprType;
 class SortType;
 class SortConstructorType;
-// not in release 1.0
-//class PredicateSubtype;
+class PredicateSubtype;
 class SubrangeType;
 class Type;
 
@@ -340,8 +339,7 @@ public:
    * Is this a predicate subtype?
    * @return true if this is a predicate subtype
    */
-  // not in release 1.0
-  //bool isPredicateSubtype() const;
+  bool isPredicateSubtype() const;
 
   /**
    * Is this an integer subrange type?
@@ -527,8 +525,6 @@ public:
 
 };/* class SortConstructorType */
 
-// not in release 1.0
-#if 0
 /**
  * Class encapsulating a predicate subtype.
  */
@@ -549,7 +545,6 @@ public:
   Type getParentType() const;
 
 };/* class PredicateSubtype */
-#endif /* 0 */
 
 /**
  * Class encapsulating an integer subrange type.
diff --git a/src/main/command_executor.cpp b/src/main/command_executor.cpp
index 556e512..fef70fe 100644
--- a/src/main/command_executor.cpp
+++ src/main/command_executor.cpp
@@ -26,7 +26,7 @@ namespace main {
 
 CommandExecutor::CommandExecutor(ExprManager &exprMgr, Options &options):
   d_exprMgr(exprMgr),
-  d_smtEngine(SmtEngine(&exprMgr)),
+  d_smtEngine(new SmtEngine(&exprMgr)),
   d_options(options),
   d_stats("driver") {
 }
@@ -58,13 +58,22 @@ bool CommandExecutor::doCommand(Command* cmd)
   }
 }
 
+void CommandExecutor::reset()
+{
+  if(d_options[options::statistics]) {
+    flushStatistics(*d_options[options::err]);
+  }
+  delete d_smtEngine;
+  d_smtEngine = new SmtEngine(&d_exprMgr);
+}
+
 bool CommandExecutor::doCommandSingleton(Command *cmd)
 {
   bool status = true;
   if(d_options[options::verbosity] >= -1) {
-    status = smtEngineInvoke(&d_smtEngine, cmd, d_options[options::out]);
+    status = smtEngineInvoke(d_smtEngine, cmd, d_options[options::out]);
   } else {
-    status = smtEngineInvoke(&d_smtEngine, cmd, NULL);
+    status = smtEngineInvoke(d_smtEngine, cmd, NULL);
   }
   //dump the model if option is set
   if(status && d_options[options::produceModels] && d_options[options::dumpModels]) {
@@ -82,7 +91,7 @@ bool CommandExecutor::doCommandSingleton(Command *cmd)
 
 std::string CommandExecutor::getSmtEngineStatus()
 {
-  return d_smtEngine.getInfo("status").getValue();
+  return d_smtEngine->getInfo("status").getValue();
 }
 
 bool smtEngineInvoke(SmtEngine* smt, Command* cmd, std::ostream *out)
diff --git a/src/main/command_executor.h b/src/main/command_executor.h
index f1b8d8f..49b6f13 100644
--- a/src/main/command_executor.h
+++ src/main/command_executor.h
@@ -31,14 +31,16 @@ class CommandExecutor {
 
 protected:
   ExprManager& d_exprMgr;
-  SmtEngine d_smtEngine;
+  SmtEngine* d_smtEngine;
   Options& d_options;
   StatisticsRegistry d_stats;
 
 public:
   CommandExecutor(ExprManager &exprMgr, Options &options);
 
-  virtual ~CommandExecutor() {}
+  virtual ~CommandExecutor() {
+    delete d_smtEngine;
+  }
 
   /**
    * Executes a command. Recursively handles if cmd is a command
@@ -47,6 +49,8 @@ public:
    */
   bool doCommand(CVC4::Command* cmd);
 
+  void reset();
+
   virtual std::string getSmtEngineStatus();
 
   StatisticsRegistry& getStatisticsRegistry() {
@@ -55,7 +59,7 @@ public:
 
   virtual void flushStatistics(std::ostream& out) const {
     d_exprMgr.getStatistics().flushInformation(out);
-    d_smtEngine.getStatistics().flushInformation(out);
+    d_smtEngine->getStatistics().flushInformation(out);
     d_stats.flushInformation(out);
   }
 
diff --git a/src/main/driver_unified.cpp b/src/main/driver_unified.cpp
index f57d4f2..c80c9b7 100644
--- a/src/main/driver_unified.cpp
+++ src/main/driver_unified.cpp
@@ -236,6 +236,9 @@ int runCvc4(int argc, char* argv[], Options& opts) {
     Command* cmd;
     bool status = true;
     if(opts[options::interactive]) {
+      if( opts[options::tearDownIncremental] ) {
+        throw OptionException("--tear-down-incremental incompatible with --interactive");
+      }
 #ifndef PORTFOLIO_BUILD
       if(!opts.wasSetByUser(options::incrementalSolving)) {
         cmd = new SetOptionCommand("incremental", true);
@@ -263,6 +266,64 @@ int runCvc4(int argc, char* argv[], Options& opts) {
         status = pExecutor->doCommand(cmd) && status;
         delete cmd;
       }
+    } else if(opts[options::tearDownIncremental]) {
+      if(opts[options::incrementalSolving]) {
+        throw OptionException("--tear-down-incremental incompatible with --incremental");
+      }
+
+      ParserBuilder parserBuilder(exprMgr, filename, opts);
+
+      if( inputFromStdin ) {
+#if defined(CVC4_COMPETITION_MODE) && !defined(CVC4_SMTCOMP_APPLICATION_TRACK)
+        parserBuilder.withStreamInput(cin);
+#else /* CVC4_COMPETITION_MODE && !CVC4_SMTCOMP_APPLICATION_TRACK */
+        parserBuilder.withLineBufferedStreamInput(cin);
+#endif /* CVC4_COMPETITION_MODE && !CVC4_SMTCOMP_APPLICATION_TRACK */
+      }
+
+      vector< vector<Command*> > allCommands;
+      allCommands.push_back(vector<Command*>());
+      Parser *parser = parserBuilder.build();
+      if(replayParser != NULL) {
+        // have the replay parser use the file's declarations
+        replayParser->useDeclarationsFrom(parser);
+      }
+      while(status && (cmd = parser->nextCommand())) {
+        if(dynamic_cast<PushCommand*>(cmd) != NULL) {
+          allCommands.push_back(vector<Command*>());
+        } else if(dynamic_cast<PopCommand*>(cmd) != NULL) {
+          allCommands.pop_back(); // fixme leaks cmds here
+          pExecutor->reset();
+          for(size_t i = 0; i < allCommands.size(); ++i) {
+            for(size_t j = 0; j < allCommands[i].size(); ++j) {
+              Command* cmd = allCommands[i][j]->clone();
+              pExecutor->doCommand(cmd);
+              delete cmd;
+            }
+          }
+        } else if(dynamic_cast<CheckSatCommand*>(cmd) != NULL ||
+                  dynamic_cast<QueryCommand*>(cmd) != NULL) {
+          status = pExecutor->doCommand(cmd);
+          pExecutor->reset();
+          for(size_t i = 0; i < allCommands.size(); ++i) {
+            for(size_t j = 0; j < allCommands[i].size(); ++j) {
+              Command* cmd = allCommands[i][j]->clone();
+              pExecutor->doCommand(cmd);
+              delete cmd;
+            }
+          }
+        } else {
+          allCommands.back().push_back(cmd->clone());
+          if(dynamic_cast<QuitCommand*>(cmd) != NULL) {
+            delete cmd;
+            break;
+          }
+          status = pExecutor->doCommand(cmd);
+        }
+        delete cmd;
+      }
+      // Remove the parser
+      delete parser;
     } else {
       ParserBuilder parserBuilder(exprMgr, filename, opts);
 
diff --git a/src/main/options b/src/main/options
index 14a7a9f..590c472 100644
--- a/src/main/options
+++ src/main/options
@@ -38,6 +38,9 @@ option fallbackSequential  --fallback-sequential bool :default false
 option incrementalParallel --incremental-parallel bool :default false :link --incremental
  Use parallel solver even in incremental mode (may print 'unknown's at times)
 
+expert-option tearDownIncremental --tear-down-incremental bool :default false
+ implement PUSH/POP/multi-query by destroying and recreating SmtEngine
+
 expert-option waitToJoin --wait-to-join bool :default true
  wait for other threads to join before quitting
 
diff --git a/src/parser/cvc/Cvc.g b/src/parser/cvc/Cvc.g
index cf21ca6..3cebf81 100644
--- a/src/parser/cvc/Cvc.g
+++ src/parser/cvc/Cvc.g
@@ -1142,11 +1142,9 @@ restrictedTypePossiblyFunctionLHS[CVC4::Type& t,
     { /*SymbolTable* old = PARSER_STATE->getSymbolTable();
       PARSER_STATE->useDeclarationsFrom(symtab);
       delete old;*/
-      PARSER_STATE->unimplementedFeature("predicate subtyping not supported in this release");
-      /*t = f2.isNull() ?
+      t = f2.isNull() ?
         EXPR_MANAGER->mkPredicateSubtype(f) :
         EXPR_MANAGER->mkPredicateSubtype(f, f2);
-      */
     }
 
     /* subrange types */
diff --git a/src/smt/options b/src/smt/options
index e5f9c2e..1da9563 100644
--- a/src/smt/options
+++ src/smt/options
@@ -10,6 +10,9 @@ common-option - --dump=MODE argument :handler CVC4::smt::dumpMode :handler-inclu
 common-option - --dump-to=FILE argument :handler CVC4::smt::dumpToFile :handler-include "smt/options_handlers.h"
  all dumping goes to FILE (instead of stdout)
 
+option forceLogic force-logic --force-logic=LOGIC LogicInfo :include "theory/logic_info.h" :handler CVC4::smt::stringToLogicInfo :handler-include "smt/options_handlers.h"
+ set the logic, and override all further attempts to change it
+
 option simplificationMode simplification-mode --simplification=MODE SimplificationMode :handler CVC4::smt::stringToSimplificationMode :default SIMPLIFICATION_MODE_BATCH :read-write :include "smt/simplification_mode.h" :handler-include "smt/options_handlers.h"
  choose simplification mode, see --simplification=help
 alias --no-simplification = --simplification=none
diff --git a/src/smt/options_handlers.h b/src/smt/options_handlers.h
index 6b8d94c..5ddd3ce 100644
--- a/src/smt/options_handlers.h
+++ src/smt/options_handlers.h
@@ -249,6 +249,19 @@ inline void dumpMode(std::string option, std::string optarg, SmtEngine* smt) {
 #endif /* CVC4_DUMPING */
 }
 
+inline LogicInfo stringToLogicInfo(std::string option, std::string optarg, SmtEngine* smt) throw(OptionException) {
+  try {
+    LogicInfo logic(optarg);
+    if(smt != NULL) {
+      smt->setLogic(logic);
+    }
+    return logic;
+  } catch(IllegalArgumentException& e) {
+    throw OptionException(std::string("invalid logic specification for --force-logic: `") +
+                          optarg + "':\n" + e.what());
+  }
+}
+
 inline SimplificationMode stringToSimplificationMode(std::string option, std::string optarg, SmtEngine* smt) throw(OptionException) {
   if(optarg == "batch") {
     return SIMPLIFICATION_MODE_BATCH;
diff --git a/src/smt/smt_engine.cpp b/src/smt/smt_engine.cpp
index ca89ce3..e830f39 100644
--- a/src/smt/smt_engine.cpp
+++ src/smt/smt_engine.cpp
@@ -821,6 +821,9 @@ LogicInfo SmtEngine::getLogicInfo() const {
 void SmtEngine::setLogicInternal() throw() {
   Assert(!d_fullyInited, "setting logic in SmtEngine but the engine has already finished initializing for this run");
 
+  if(options::forceLogic.wasSetByUser()) {
+    d_logic = options::forceLogic();
+  }
   d_logic.lock();
 
   // Set the options for the theoryOf
@@ -2750,9 +2753,16 @@ void SmtEnginePrivate::processAssertions() {
     // We also can't use an iterator, because the vector may be moved in
     // memory during this loop.
     Chat() << "constraining subtypes..." << endl;
-    for(unsigned i = 0, i_end = d_assertionsToPreprocess.size(); i != i_end; ++i) {
+    unsigned i, i_end;
+    for(i = 0, i_end = d_assertionsToPreprocess.size(); i != i_end; ++i) {
       constrainSubtypes(d_assertionsToPreprocess[i], d_assertionsToPreprocess);
     }
+    Chat() << "...re-expanding..." << endl;
+    hash_map<Node, Node, NodeHashFunction> cache;
+    for(; i < d_assertionsToPreprocess.size(); ++i) {
+      d_assertionsToPreprocess[i] =
+        expandDefinitions(d_assertionsToPreprocess[i], cache);
+    }
   }
   dumpAssertions("post-constrain-subtypes", d_assertionsToPreprocess);
 
@@ -2809,6 +2819,9 @@ void SmtEnginePrivate::processAssertions() {
     d_smt.d_theoryEngine->getSortInference()->simplify( d_assertionsToPreprocess );
   }
 
+  Assert(d_assertionsToCheck.size() == 0);
+  d_realAssertionsEnd = d_assertionsToPreprocess.size();
+
   dumpAssertions("pre-simplify", d_assertionsToPreprocess);
   Chat() << "simplifying assertions..." << endl;
   bool noConflict = simplifyAssertions();
@@ -3260,7 +3273,15 @@ Expr SmtEngine::getValue(const Expr& ex) throw(ModalException, TypeCheckingExcep
   Trace("smt") << "--- model-post expected " << n.getType() << endl;
 
   // type-check the result we got
-  Assert(resultNode.isNull() || resultNode.getType().isSubtypeOf(n.getType()));
+  Assert(resultNode.isNull() ||
+         resultNode.getType().isSubtypeOf(n.getType()) ||
+         // assertion here is really ugly because we made integer literals INT rather than
+         // subrange_bound(k,k).  :-(
+ /*        ( resultNode.isConst() && resultNode.getType().isInteger() &&
+           n.getType().isSubrange() && SubrangeBounds(resultNode.getConst<Rational>().getNumerator(), resultNode.getConst<Rational>().getNumerator()) <= n.getType().getSubrangeBounds() ),*/
+         "incorrect type `%s' for model-returned value `%s': expected type `%s'",
+         resultNode.getType().toString().c_str(), resultNode.toString().c_str(),
+         n.getType().toString().c_str());
 
   // ensure it's a constant
   Assert(resultNode.getKind() == kind::LAMBDA || resultNode.isConst());
diff --git a/src/theory/arith/theory_arith_type_rules.h b/src/theory/arith/theory_arith_type_rules.h
index cc8451f..9c59b0f 100644
--- a/src/theory/arith/theory_arith_type_rules.h
+++ src/theory/arith/theory_arith_type_rules.h
@@ -32,7 +32,8 @@ public:
       throw (TypeCheckingExceptionPrivate, AssertionException) {
     Assert(n.getKind() == kind::CONST_RATIONAL);
     if(n.getConst<Rational>().isIntegral()){
-      return nodeManager->integerType();
+      Integer k = n.getConst<Rational>().getNumerator();
+      return nodeManager->mkSubrangeType(SubrangeBounds(k, k));
     }else{
       return nodeManager->realType();
     }
diff --git a/src/theory/term_registration_visitor.cpp b/src/theory/term_registration_visitor.cpp
index 558975a..d454bc3 100644
--- a/src/theory/term_registration_visitor.cpp
+++ src/theory/term_registration_visitor.cpp
@@ -173,6 +173,9 @@ bool SharedTermsVisitor::alreadyVisited(TNode current, TNode parent) const {
       typeTheoryId = Theory::theoryOf(type);
     } else {
       TypeNode type = current.getType();
+      while(type.isPredicateSubtype()) {
+        type = type.getSubtypeParentType();
+      }
       typeTheoryId = Theory::theoryOf(type);
       if (typeTheoryId != currentTheoryId) {
         if (options::finiteModelFind() && type.isSort()) {
@@ -226,6 +229,9 @@ void SharedTermsVisitor::visit(TNode current, TNode parent) {
       typeTheoryId = Theory::theoryOf(type);
     } else {
       TypeNode type = current.getType();
+      while(type.isPredicateSubtype()) {
+        type = type.getSubtypeParentType();
+      }
       typeTheoryId = Theory::theoryOf(type);
       if (typeTheoryId != currentTheoryId) {
         if (options::finiteModelFind() && type.isSort()) {
diff --git a/src/theory/uf/theory_uf_type_rules.h b/src/theory/uf/theory_uf_type_rules.h
index b9a8ed1..2ccf405 100644
--- a/src/theory/uf/theory_uf_type_rules.h
+++ src/theory/uf/theory_uf_type_rules.h
@@ -62,7 +62,7 @@ public:
       throw(TypeCheckingExceptionPrivate) {
     if( check ) {
       TypeNode valType = n[1].getType(check);
-      if( valType != nodeManager->integerType() ) {
+      if( !valType.isSubtypeOf(nodeManager->integerType()) ) {
         throw TypeCheckingExceptionPrivate(n, "cardinality constraint must be integer");
       }
     }
